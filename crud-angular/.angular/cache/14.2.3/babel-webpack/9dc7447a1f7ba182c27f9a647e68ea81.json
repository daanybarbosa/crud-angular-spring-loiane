{"ast":null,"code":"'use strict';\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * @suppress {globalThis,undefinedVars}\n */\n\nZone.__load_patch('Error', (global, Zone, api) => {\n  /*\n   * This code patches Error so that:\n   *   - It ignores un-needed stack frames.\n   *   - It Shows the associated Zone for reach frame.\n   */\n  const zoneJsInternalStackFramesSymbol = api.symbol('zoneJsInternalStackFrames');\n  const NativeError = global[api.symbol('Error')] = global['Error']; // Store the frames which should be removed from the stack frames\n\n  const zoneJsInternalStackFrames = {}; // We must find the frame where Error was created, otherwise we assume we don't understand stack\n\n  let zoneAwareFrame1;\n  let zoneAwareFrame2;\n  let zoneAwareFrame1WithoutNew;\n  let zoneAwareFrame2WithoutNew;\n  let zoneAwareFrame3WithoutNew;\n  global['Error'] = ZoneAwareError;\n  const stackRewrite = 'stackRewrite';\n  const zoneJsInternalStackFramesPolicy = global['__Zone_Error_BlacklistedStackFrames_policy'] || global['__Zone_Error_ZoneJsInternalStackFrames_policy'] || 'default';\n\n  function buildZoneFrameNames(zoneFrame) {\n    let zoneFrameName = {\n      zoneName: zoneFrame.zone.name\n    };\n    let result = zoneFrameName;\n\n    while (zoneFrame.parent) {\n      zoneFrame = zoneFrame.parent;\n      const parentZoneFrameName = {\n        zoneName: zoneFrame.zone.name\n      };\n      zoneFrameName.parent = parentZoneFrameName;\n      zoneFrameName = parentZoneFrameName;\n    }\n\n    return result;\n  }\n\n  function buildZoneAwareStackFrames(originalStack, zoneFrame, isZoneFrame = true) {\n    let frames = originalStack.split('\\n');\n    let i = 0; // Find the first frame\n\n    while (!(frames[i] === zoneAwareFrame1 || frames[i] === zoneAwareFrame2 || frames[i] === zoneAwareFrame1WithoutNew || frames[i] === zoneAwareFrame2WithoutNew || frames[i] === zoneAwareFrame3WithoutNew) && i < frames.length) {\n      i++;\n    }\n\n    for (; i < frames.length && zoneFrame; i++) {\n      let frame = frames[i];\n\n      if (frame.trim()) {\n        switch (zoneJsInternalStackFrames[frame]) {\n          case 0\n          /* FrameType.zoneJsInternal */\n          :\n            frames.splice(i, 1);\n            i--;\n            break;\n\n          case 1\n          /* FrameType.transition */\n          :\n            if (zoneFrame.parent) {\n              // This is the special frame where zone changed. Print and process it accordingly\n              zoneFrame = zoneFrame.parent;\n            } else {\n              zoneFrame = null;\n            }\n\n            frames.splice(i, 1);\n            i--;\n            break;\n\n          default:\n            frames[i] += isZoneFrame ? ` [${zoneFrame.zone.name}]` : ` [${zoneFrame.zoneName}]`;\n        }\n      }\n    }\n\n    return frames.join('\\n');\n  }\n  /**\n   * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n   * adds zone information to it.\n   */\n\n\n  function ZoneAwareError() {\n    // We always have to return native error otherwise the browser console will not work.\n    let error = NativeError.apply(this, arguments); // Save original stack trace\n\n    const originalStack = error['originalStack'] = error.stack; // Process the stack trace and rewrite the frames.\n\n    if (ZoneAwareError[stackRewrite] && originalStack) {\n      let zoneFrame = api.currentZoneFrame();\n\n      if (zoneJsInternalStackFramesPolicy === 'lazy') {\n        // don't handle stack trace now\n        error[api.symbol('zoneFrameNames')] = buildZoneFrameNames(zoneFrame);\n      } else if (zoneJsInternalStackFramesPolicy === 'default') {\n        try {\n          error.stack = error.zoneAwareStack = buildZoneAwareStackFrames(originalStack, zoneFrame);\n        } catch (e) {// ignore as some browsers don't allow overriding of stack\n        }\n      }\n    }\n\n    if (this instanceof NativeError && this.constructor != NativeError) {\n      // We got called with a `new` operator AND we are subclass of ZoneAwareError\n      // in that case we have to copy all of our properties to `this`.\n      Object.keys(error).concat('stack', 'message').forEach(key => {\n        const value = error[key];\n\n        if (value !== undefined) {\n          try {\n            this[key] = value;\n          } catch (e) {// ignore the assignment in case it is a setter and it throws.\n          }\n        }\n      });\n      return this;\n    }\n\n    return error;\n  } // Copy the prototype so that instanceof operator works as expected\n\n\n  ZoneAwareError.prototype = NativeError.prototype;\n  ZoneAwareError[zoneJsInternalStackFramesSymbol] = zoneJsInternalStackFrames;\n  ZoneAwareError[stackRewrite] = false;\n  const zoneAwareStackSymbol = api.symbol('zoneAwareStack'); // try to define zoneAwareStack property when zoneJsInternal frames policy is delay\n\n  if (zoneJsInternalStackFramesPolicy === 'lazy') {\n    Object.defineProperty(ZoneAwareError.prototype, 'zoneAwareStack', {\n      configurable: true,\n      enumerable: true,\n      get: function () {\n        if (!this[zoneAwareStackSymbol]) {\n          this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n        }\n\n        return this[zoneAwareStackSymbol];\n      },\n      set: function (newStack) {\n        this.originalStack = newStack;\n        this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n      }\n    });\n  } // those properties need special handling\n\n\n  const specialPropertyNames = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace']; // those properties of NativeError should be set to ZoneAwareError\n\n  const nativeErrorProperties = Object.keys(NativeError);\n\n  if (nativeErrorProperties) {\n    nativeErrorProperties.forEach(prop => {\n      if (specialPropertyNames.filter(sp => sp === prop).length === 0) {\n        Object.defineProperty(ZoneAwareError, prop, {\n          get: function () {\n            return NativeError[prop];\n          },\n          set: function (value) {\n            NativeError[prop] = value;\n          }\n        });\n      }\n    });\n  }\n\n  if (NativeError.hasOwnProperty('stackTraceLimit')) {\n    // Extend default stack limit as we will be removing few frames.\n    NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15); // make sure that ZoneAwareError has the same property which forwards to NativeError.\n\n    Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n      get: function () {\n        return NativeError.stackTraceLimit;\n      },\n      set: function (value) {\n        return NativeError.stackTraceLimit = value;\n      }\n    });\n  }\n\n  if (NativeError.hasOwnProperty('captureStackTrace')) {\n    Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n      // add named function here because we need to remove this\n      // stack frame when prepareStackTrace below\n      value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n        NativeError.captureStackTrace(targetObject, constructorOpt);\n      }\n    });\n  }\n\n  const ZONE_CAPTURESTACKTRACE = 'zoneCaptureStackTrace';\n  Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n    get: function () {\n      return NativeError.prepareStackTrace;\n    },\n    set: function (value) {\n      if (!value || typeof value !== 'function') {\n        return NativeError.prepareStackTrace = value;\n      }\n\n      return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n        // remove additional stack information from ZoneAwareError.captureStackTrace\n        if (structuredStackTrace) {\n          for (let i = 0; i < structuredStackTrace.length; i++) {\n            const st = structuredStackTrace[i]; // remove the first function which name is zoneCaptureStackTrace\n\n            if (st.getFunctionName() === ZONE_CAPTURESTACKTRACE) {\n              structuredStackTrace.splice(i, 1);\n              break;\n            }\n          }\n        }\n\n        return value.call(this, error, structuredStackTrace);\n      };\n    }\n  });\n\n  if (zoneJsInternalStackFramesPolicy === 'disable') {\n    // don't need to run detectZone to populate zoneJs internal stack frames\n    return;\n  } // Now we need to populate the `zoneJsInternalStackFrames` as well as find the\n  // run/runGuarded/runTask frames. This is done by creating a detect zone and then threading\n  // the execution through all of the above methods so that we can look at the stack trace and\n  // find the frames of interest.\n\n\n  let detectZone = Zone.current.fork({\n    name: 'detect',\n    onHandleError: function (parentZD, current, target, error) {\n      if (error.originalStack && Error === ZoneAwareError) {\n        let frames = error.originalStack.split(/\\n/);\n        let runFrame = false,\n            runGuardedFrame = false,\n            runTaskFrame = false;\n\n        while (frames.length) {\n          let frame = frames.shift(); // On safari it is possible to have stack frame with no line number.\n          // This check makes sure that we don't filter frames on name only (must have\n          // line number or exact equals to `ZoneAwareError`)\n\n          if (/:\\d+:\\d+/.test(frame) || frame === 'ZoneAwareError') {\n            // Get rid of the path so that we don't accidentally find function name in path.\n            // In chrome the separator is `(` and `@` in FF and safari\n            // Chrome: at Zone.run (zone.js:100)\n            // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n            // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n            // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n            let fnName = frame.split('(')[0].split('@')[0];\n            let frameType = 1\n            /* FrameType.transition */\n            ;\n\n            if (fnName.indexOf('ZoneAwareError') !== -1) {\n              if (fnName.indexOf('new ZoneAwareError') !== -1) {\n                zoneAwareFrame1 = frame;\n                zoneAwareFrame2 = frame.replace('new ZoneAwareError', 'new Error.ZoneAwareError');\n              } else {\n                zoneAwareFrame1WithoutNew = frame;\n                zoneAwareFrame2WithoutNew = frame.replace('Error.', '');\n\n                if (frame.indexOf('Error.ZoneAwareError') === -1) {\n                  zoneAwareFrame3WithoutNew = frame.replace('ZoneAwareError', 'Error.ZoneAwareError');\n                }\n              }\n\n              zoneJsInternalStackFrames[zoneAwareFrame2] = 0\n              /* FrameType.zoneJsInternal */\n              ;\n            }\n\n            if (fnName.indexOf('runGuarded') !== -1) {\n              runGuardedFrame = true;\n            } else if (fnName.indexOf('runTask') !== -1) {\n              runTaskFrame = true;\n            } else if (fnName.indexOf('run') !== -1) {\n              runFrame = true;\n            } else {\n              frameType = 0\n              /* FrameType.zoneJsInternal */\n              ;\n            }\n\n            zoneJsInternalStackFrames[frame] = frameType; // Once we find all of the frames we can stop looking.\n\n            if (runFrame && runGuardedFrame && runTaskFrame) {\n              ZoneAwareError[stackRewrite] = true;\n              break;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  }); // carefully constructor a stack frame which contains all of the frames of interest which\n  // need to be detected and marked as an internal zoneJs frame.\n\n  const childDetectZone = detectZone.fork({\n    name: 'child',\n    onScheduleTask: function (delegate, curr, target, task) {\n      return delegate.scheduleTask(target, task);\n    },\n    onInvokeTask: function (delegate, curr, target, task, applyThis, applyArgs) {\n      return delegate.invokeTask(target, task, applyThis, applyArgs);\n    },\n    onCancelTask: function (delegate, curr, target, task) {\n      return delegate.cancelTask(target, task);\n    },\n    onInvoke: function (delegate, curr, target, callback, applyThis, applyArgs, source) {\n      return delegate.invoke(target, callback, applyThis, applyArgs, source);\n    }\n  }); // we need to detect all zone related frames, it will\n  // exceed default stackTraceLimit, so we set it to\n  // larger number here, and restore it after detect finish.\n  // We cast through any so we don't need to depend on nodejs typings.\n\n  const originalStackTraceLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = 100; // we schedule event/micro/macro task, and invoke them\n  // when onSchedule, so we can get all stack traces for\n  // all kinds of tasks with one error thrown.\n\n  childDetectZone.run(() => {\n    childDetectZone.runGuarded(() => {\n      const fakeTransitionTo = () => {};\n\n      childDetectZone.scheduleEventTask(zoneJsInternalStackFramesSymbol, () => {\n        childDetectZone.scheduleMacroTask(zoneJsInternalStackFramesSymbol, () => {\n          childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n            throw new Error();\n          }, undefined, t => {\n            t._transitionTo = fakeTransitionTo;\n            t.invoke();\n          });\n          childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n            throw Error();\n          }, undefined, t => {\n            t._transitionTo = fakeTransitionTo;\n            t.invoke();\n          });\n        }, undefined, t => {\n          t._transitionTo = fakeTransitionTo;\n          t.invoke();\n        }, () => {});\n      }, undefined, t => {\n        t._transitionTo = fakeTransitionTo;\n        t.invoke();\n      }, () => {});\n    });\n  });\n  Error.stackTraceLimit = originalStackTraceLimit;\n});","map":{"version":3,"names":["Zone","__load_patch","global","api","zoneJsInternalStackFramesSymbol","symbol","NativeError","zoneJsInternalStackFrames","zoneAwareFrame1","zoneAwareFrame2","zoneAwareFrame1WithoutNew","zoneAwareFrame2WithoutNew","zoneAwareFrame3WithoutNew","ZoneAwareError","stackRewrite","zoneJsInternalStackFramesPolicy","buildZoneFrameNames","zoneFrame","zoneFrameName","zoneName","zone","name","result","parent","parentZoneFrameName","buildZoneAwareStackFrames","originalStack","isZoneFrame","frames","split","i","length","frame","trim","splice","join","error","apply","arguments","stack","currentZoneFrame","zoneAwareStack","e","constructor","Object","keys","concat","forEach","key","value","undefined","prototype","zoneAwareStackSymbol","defineProperty","configurable","enumerable","get","set","newStack","specialPropertyNames","nativeErrorProperties","prop","filter","sp","hasOwnProperty","stackTraceLimit","Math","max","zoneCaptureStackTrace","targetObject","constructorOpt","captureStackTrace","ZONE_CAPTURESTACKTRACE","prepareStackTrace","structuredStackTrace","st","getFunctionName","call","detectZone","current","fork","onHandleError","parentZD","target","Error","runFrame","runGuardedFrame","runTaskFrame","shift","test","fnName","frameType","indexOf","replace","childDetectZone","onScheduleTask","delegate","curr","task","scheduleTask","onInvokeTask","applyThis","applyArgs","invokeTask","onCancelTask","cancelTask","onInvoke","callback","source","invoke","originalStackTraceLimit","run","runGuarded","fakeTransitionTo","scheduleEventTask","scheduleMacroTask","scheduleMicroTask","t","_transitionTo"],"sources":["/Users/danielebsilva/Estudos/angular/crud-angular-spring-loiane/crud-angular/node_modules/zone.js/fesm2015/zone-error.js"],"sourcesContent":["'use strict';\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview\n * @suppress {globalThis,undefinedVars}\n */\nZone.__load_patch('Error', (global, Zone, api) => {\n    /*\n     * This code patches Error so that:\n     *   - It ignores un-needed stack frames.\n     *   - It Shows the associated Zone for reach frame.\n     */\n    const zoneJsInternalStackFramesSymbol = api.symbol('zoneJsInternalStackFrames');\n    const NativeError = global[api.symbol('Error')] = global['Error'];\n    // Store the frames which should be removed from the stack frames\n    const zoneJsInternalStackFrames = {};\n    // We must find the frame where Error was created, otherwise we assume we don't understand stack\n    let zoneAwareFrame1;\n    let zoneAwareFrame2;\n    let zoneAwareFrame1WithoutNew;\n    let zoneAwareFrame2WithoutNew;\n    let zoneAwareFrame3WithoutNew;\n    global['Error'] = ZoneAwareError;\n    const stackRewrite = 'stackRewrite';\n    const zoneJsInternalStackFramesPolicy = global['__Zone_Error_BlacklistedStackFrames_policy'] ||\n        global['__Zone_Error_ZoneJsInternalStackFrames_policy'] || 'default';\n    function buildZoneFrameNames(zoneFrame) {\n        let zoneFrameName = { zoneName: zoneFrame.zone.name };\n        let result = zoneFrameName;\n        while (zoneFrame.parent) {\n            zoneFrame = zoneFrame.parent;\n            const parentZoneFrameName = { zoneName: zoneFrame.zone.name };\n            zoneFrameName.parent = parentZoneFrameName;\n            zoneFrameName = parentZoneFrameName;\n        }\n        return result;\n    }\n    function buildZoneAwareStackFrames(originalStack, zoneFrame, isZoneFrame = true) {\n        let frames = originalStack.split('\\n');\n        let i = 0;\n        // Find the first frame\n        while (!(frames[i] === zoneAwareFrame1 || frames[i] === zoneAwareFrame2 ||\n            frames[i] === zoneAwareFrame1WithoutNew || frames[i] === zoneAwareFrame2WithoutNew ||\n            frames[i] === zoneAwareFrame3WithoutNew) &&\n            i < frames.length) {\n            i++;\n        }\n        for (; i < frames.length && zoneFrame; i++) {\n            let frame = frames[i];\n            if (frame.trim()) {\n                switch (zoneJsInternalStackFrames[frame]) {\n                    case 0 /* FrameType.zoneJsInternal */:\n                        frames.splice(i, 1);\n                        i--;\n                        break;\n                    case 1 /* FrameType.transition */:\n                        if (zoneFrame.parent) {\n                            // This is the special frame where zone changed. Print and process it accordingly\n                            zoneFrame = zoneFrame.parent;\n                        }\n                        else {\n                            zoneFrame = null;\n                        }\n                        frames.splice(i, 1);\n                        i--;\n                        break;\n                    default:\n                        frames[i] += isZoneFrame ? ` [${zoneFrame.zone.name}]` :\n                            ` [${zoneFrame.zoneName}]`;\n                }\n            }\n        }\n        return frames.join('\\n');\n    }\n    /**\n     * This is ZoneAwareError which processes the stack frame and cleans up extra frames as well as\n     * adds zone information to it.\n     */\n    function ZoneAwareError() {\n        // We always have to return native error otherwise the browser console will not work.\n        let error = NativeError.apply(this, arguments);\n        // Save original stack trace\n        const originalStack = error['originalStack'] = error.stack;\n        // Process the stack trace and rewrite the frames.\n        if (ZoneAwareError[stackRewrite] && originalStack) {\n            let zoneFrame = api.currentZoneFrame();\n            if (zoneJsInternalStackFramesPolicy === 'lazy') {\n                // don't handle stack trace now\n                error[api.symbol('zoneFrameNames')] = buildZoneFrameNames(zoneFrame);\n            }\n            else if (zoneJsInternalStackFramesPolicy === 'default') {\n                try {\n                    error.stack = error.zoneAwareStack = buildZoneAwareStackFrames(originalStack, zoneFrame);\n                }\n                catch (e) {\n                    // ignore as some browsers don't allow overriding of stack\n                }\n            }\n        }\n        if (this instanceof NativeError && this.constructor != NativeError) {\n            // We got called with a `new` operator AND we are subclass of ZoneAwareError\n            // in that case we have to copy all of our properties to `this`.\n            Object.keys(error).concat('stack', 'message').forEach((key) => {\n                const value = error[key];\n                if (value !== undefined) {\n                    try {\n                        this[key] = value;\n                    }\n                    catch (e) {\n                        // ignore the assignment in case it is a setter and it throws.\n                    }\n                }\n            });\n            return this;\n        }\n        return error;\n    }\n    // Copy the prototype so that instanceof operator works as expected\n    ZoneAwareError.prototype = NativeError.prototype;\n    ZoneAwareError[zoneJsInternalStackFramesSymbol] = zoneJsInternalStackFrames;\n    ZoneAwareError[stackRewrite] = false;\n    const zoneAwareStackSymbol = api.symbol('zoneAwareStack');\n    // try to define zoneAwareStack property when zoneJsInternal frames policy is delay\n    if (zoneJsInternalStackFramesPolicy === 'lazy') {\n        Object.defineProperty(ZoneAwareError.prototype, 'zoneAwareStack', {\n            configurable: true,\n            enumerable: true,\n            get: function () {\n                if (!this[zoneAwareStackSymbol]) {\n                    this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n                }\n                return this[zoneAwareStackSymbol];\n            },\n            set: function (newStack) {\n                this.originalStack = newStack;\n                this[zoneAwareStackSymbol] = buildZoneAwareStackFrames(this.originalStack, this[api.symbol('zoneFrameNames')], false);\n            }\n        });\n    }\n    // those properties need special handling\n    const specialPropertyNames = ['stackTraceLimit', 'captureStackTrace', 'prepareStackTrace'];\n    // those properties of NativeError should be set to ZoneAwareError\n    const nativeErrorProperties = Object.keys(NativeError);\n    if (nativeErrorProperties) {\n        nativeErrorProperties.forEach(prop => {\n            if (specialPropertyNames.filter(sp => sp === prop).length === 0) {\n                Object.defineProperty(ZoneAwareError, prop, {\n                    get: function () {\n                        return NativeError[prop];\n                    },\n                    set: function (value) {\n                        NativeError[prop] = value;\n                    }\n                });\n            }\n        });\n    }\n    if (NativeError.hasOwnProperty('stackTraceLimit')) {\n        // Extend default stack limit as we will be removing few frames.\n        NativeError.stackTraceLimit = Math.max(NativeError.stackTraceLimit, 15);\n        // make sure that ZoneAwareError has the same property which forwards to NativeError.\n        Object.defineProperty(ZoneAwareError, 'stackTraceLimit', {\n            get: function () {\n                return NativeError.stackTraceLimit;\n            },\n            set: function (value) {\n                return NativeError.stackTraceLimit = value;\n            }\n        });\n    }\n    if (NativeError.hasOwnProperty('captureStackTrace')) {\n        Object.defineProperty(ZoneAwareError, 'captureStackTrace', {\n            // add named function here because we need to remove this\n            // stack frame when prepareStackTrace below\n            value: function zoneCaptureStackTrace(targetObject, constructorOpt) {\n                NativeError.captureStackTrace(targetObject, constructorOpt);\n            }\n        });\n    }\n    const ZONE_CAPTURESTACKTRACE = 'zoneCaptureStackTrace';\n    Object.defineProperty(ZoneAwareError, 'prepareStackTrace', {\n        get: function () {\n            return NativeError.prepareStackTrace;\n        },\n        set: function (value) {\n            if (!value || typeof value !== 'function') {\n                return NativeError.prepareStackTrace = value;\n            }\n            return NativeError.prepareStackTrace = function (error, structuredStackTrace) {\n                // remove additional stack information from ZoneAwareError.captureStackTrace\n                if (structuredStackTrace) {\n                    for (let i = 0; i < structuredStackTrace.length; i++) {\n                        const st = structuredStackTrace[i];\n                        // remove the first function which name is zoneCaptureStackTrace\n                        if (st.getFunctionName() === ZONE_CAPTURESTACKTRACE) {\n                            structuredStackTrace.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n                return value.call(this, error, structuredStackTrace);\n            };\n        }\n    });\n    if (zoneJsInternalStackFramesPolicy === 'disable') {\n        // don't need to run detectZone to populate zoneJs internal stack frames\n        return;\n    }\n    // Now we need to populate the `zoneJsInternalStackFrames` as well as find the\n    // run/runGuarded/runTask frames. This is done by creating a detect zone and then threading\n    // the execution through all of the above methods so that we can look at the stack trace and\n    // find the frames of interest.\n    let detectZone = Zone.current.fork({\n        name: 'detect',\n        onHandleError: function (parentZD, current, target, error) {\n            if (error.originalStack && Error === ZoneAwareError) {\n                let frames = error.originalStack.split(/\\n/);\n                let runFrame = false, runGuardedFrame = false, runTaskFrame = false;\n                while (frames.length) {\n                    let frame = frames.shift();\n                    // On safari it is possible to have stack frame with no line number.\n                    // This check makes sure that we don't filter frames on name only (must have\n                    // line number or exact equals to `ZoneAwareError`)\n                    if (/:\\d+:\\d+/.test(frame) || frame === 'ZoneAwareError') {\n                        // Get rid of the path so that we don't accidentally find function name in path.\n                        // In chrome the separator is `(` and `@` in FF and safari\n                        // Chrome: at Zone.run (zone.js:100)\n                        // Chrome: at Zone.run (http://localhost:9876/base/build/lib/zone.js:100:24)\n                        // FireFox: Zone.prototype.run@http://localhost:9876/base/build/lib/zone.js:101:24\n                        // Safari: run@http://localhost:9876/base/build/lib/zone.js:101:24\n                        let fnName = frame.split('(')[0].split('@')[0];\n                        let frameType = 1 /* FrameType.transition */;\n                        if (fnName.indexOf('ZoneAwareError') !== -1) {\n                            if (fnName.indexOf('new ZoneAwareError') !== -1) {\n                                zoneAwareFrame1 = frame;\n                                zoneAwareFrame2 = frame.replace('new ZoneAwareError', 'new Error.ZoneAwareError');\n                            }\n                            else {\n                                zoneAwareFrame1WithoutNew = frame;\n                                zoneAwareFrame2WithoutNew = frame.replace('Error.', '');\n                                if (frame.indexOf('Error.ZoneAwareError') === -1) {\n                                    zoneAwareFrame3WithoutNew =\n                                        frame.replace('ZoneAwareError', 'Error.ZoneAwareError');\n                                }\n                            }\n                            zoneJsInternalStackFrames[zoneAwareFrame2] = 0 /* FrameType.zoneJsInternal */;\n                        }\n                        if (fnName.indexOf('runGuarded') !== -1) {\n                            runGuardedFrame = true;\n                        }\n                        else if (fnName.indexOf('runTask') !== -1) {\n                            runTaskFrame = true;\n                        }\n                        else if (fnName.indexOf('run') !== -1) {\n                            runFrame = true;\n                        }\n                        else {\n                            frameType = 0 /* FrameType.zoneJsInternal */;\n                        }\n                        zoneJsInternalStackFrames[frame] = frameType;\n                        // Once we find all of the frames we can stop looking.\n                        if (runFrame && runGuardedFrame && runTaskFrame) {\n                            ZoneAwareError[stackRewrite] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n    });\n    // carefully constructor a stack frame which contains all of the frames of interest which\n    // need to be detected and marked as an internal zoneJs frame.\n    const childDetectZone = detectZone.fork({\n        name: 'child',\n        onScheduleTask: function (delegate, curr, target, task) {\n            return delegate.scheduleTask(target, task);\n        },\n        onInvokeTask: function (delegate, curr, target, task, applyThis, applyArgs) {\n            return delegate.invokeTask(target, task, applyThis, applyArgs);\n        },\n        onCancelTask: function (delegate, curr, target, task) {\n            return delegate.cancelTask(target, task);\n        },\n        onInvoke: function (delegate, curr, target, callback, applyThis, applyArgs, source) {\n            return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        }\n    });\n    // we need to detect all zone related frames, it will\n    // exceed default stackTraceLimit, so we set it to\n    // larger number here, and restore it after detect finish.\n    // We cast through any so we don't need to depend on nodejs typings.\n    const originalStackTraceLimit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 100;\n    // we schedule event/micro/macro task, and invoke them\n    // when onSchedule, so we can get all stack traces for\n    // all kinds of tasks with one error thrown.\n    childDetectZone.run(() => {\n        childDetectZone.runGuarded(() => {\n            const fakeTransitionTo = () => { };\n            childDetectZone.scheduleEventTask(zoneJsInternalStackFramesSymbol, () => {\n                childDetectZone.scheduleMacroTask(zoneJsInternalStackFramesSymbol, () => {\n                    childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n                        throw new Error();\n                    }, undefined, (t) => {\n                        t._transitionTo = fakeTransitionTo;\n                        t.invoke();\n                    });\n                    childDetectZone.scheduleMicroTask(zoneJsInternalStackFramesSymbol, () => {\n                        throw Error();\n                    }, undefined, (t) => {\n                        t._transitionTo = fakeTransitionTo;\n                        t.invoke();\n                    });\n                }, undefined, (t) => {\n                    t._transitionTo = fakeTransitionTo;\n                    t.invoke();\n                }, () => { });\n            }, undefined, (t) => {\n                t._transitionTo = fakeTransitionTo;\n                t.invoke();\n            }, () => { });\n        });\n    });\n    Error.stackTraceLimit = originalStackTraceLimit;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}